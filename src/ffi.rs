/* automatically generated by rust-bindgen 0.54.1 */

pub const RT_NAME_MAX: u32 = 8;
pub const RT_ALIGN_SIZE: u32 = 4;
pub const RT_THREAD_PRIORITY_MAX: u32 = 32;
pub const RT_TICK_PER_SECOND: u32 = 1000;
pub const RT_IDLE_HOOK_LIST_SIZE: u32 = 4;
pub const IDLE_THREAD_STACK_SIZE: u32 = 256;
pub const RT_CONSOLEBUF_SIZE: u32 = 128;
pub const RT_CONSOLE_DEVICE_NAME: &'static [u8; 6usize] = b"uart1\0";
pub const RT_VER_NUM: u32 = 262145;
pub const RT_MAIN_THREAD_STACK_SIZE: u32 = 2048;
pub const RT_MAIN_THREAD_PRIORITY: u32 = 10;
pub const FINSH_THREAD_NAME: &'static [u8; 7usize] = b"tshell\0";
pub const FINSH_HISTORY_LINES: u32 = 5;
pub const FINSH_THREAD_PRIORITY: u32 = 20;
pub const FINSH_THREAD_STACK_SIZE: u32 = 4096;
pub const FINSH_CMD_SIZE: u32 = 80;
pub const FINSH_ARG_MAX: u32 = 10;
pub const RT_PIPE_BUFSZ: u32 = 512;
pub const RT_SERIAL_RB_BUFSZ: u32 = 64;
pub const RT_DEBUG_MEM: u32 = 0;
pub const RT_DEBUG_MEMHEAP: u32 = 0;
pub const RT_DEBUG_MODULE: u32 = 0;
pub const RT_DEBUG_SCHEDULER: u32 = 0;
pub const RT_DEBUG_SLAB: u32 = 0;
pub const RT_DEBUG_THREAD: u32 = 0;
pub const RT_DEBUG_TIMER: u32 = 0;
pub const RT_DEBUG_IRQ: u32 = 0;
pub const RT_DEBUG_IPC: u32 = 0;
pub const RT_DEBUG_INIT: u32 = 0;
pub const RT_DEBUG_CONTEXT_CHECK: u32 = 1;
pub const RT_VERSION: u32 = 4;
pub const RT_SUBVERSION: u32 = 0;
pub const RT_REVISION: u32 = 3;
pub const RTTHREAD_VERSION: u32 = 40003;
pub const RT_TRUE: u32 = 1;
pub const RT_FALSE: u32 = 0;
pub const RT_UINT8_MAX: u32 = 255;
pub const RT_UINT16_MAX: u32 = 65535;
pub const RT_UINT32_MAX: u32 = 4294967295;
pub const RT_TICK_MAX: u32 = 4294967295;
pub const RT_EVENT_LENGTH: u32 = 32;
pub const RT_MM_PAGE_SIZE: u32 = 4096;
pub const RT_MM_PAGE_MASK: u32 = 4095;
pub const RT_MM_PAGE_BITS: u32 = 12;
pub const RT_EOK: u32 = 0;
pub const RT_ERROR: u32 = 1;
pub const RT_ETIMEOUT: u32 = 2;
pub const RT_EFULL: u32 = 3;
pub const RT_EEMPTY: u32 = 4;
pub const RT_ENOMEM: u32 = 5;
pub const RT_ENOSYS: u32 = 6;
pub const RT_EBUSY: u32 = 7;
pub const RT_EIO: u32 = 8;
pub const RT_EINTR: u32 = 9;
pub const RT_EINVAL: u32 = 10;
pub const RT_NULL: u32 = 0;
pub const RT_OBJECT_FLAG_MODULE: u32 = 128;
pub const RT_TIMER_FLAG_DEACTIVATED: u32 = 0;
pub const RT_TIMER_FLAG_ACTIVATED: u32 = 1;
pub const RT_TIMER_FLAG_ONE_SHOT: u32 = 0;
pub const RT_TIMER_FLAG_PERIODIC: u32 = 2;
pub const RT_TIMER_FLAG_HARD_TIMER: u32 = 0;
pub const RT_TIMER_FLAG_SOFT_TIMER: u32 = 4;
pub const RT_TIMER_CTRL_SET_TIME: u32 = 0;
pub const RT_TIMER_CTRL_GET_TIME: u32 = 1;
pub const RT_TIMER_CTRL_SET_ONESHOT: u32 = 2;
pub const RT_TIMER_CTRL_SET_PERIODIC: u32 = 3;
pub const RT_TIMER_CTRL_GET_STATE: u32 = 4;
pub const RT_TIMER_SKIP_LIST_LEVEL: u32 = 1;
pub const RT_TIMER_SKIP_LIST_MASK: u32 = 3;
pub const RT_THREAD_INIT: u32 = 0;
pub const RT_THREAD_READY: u32 = 1;
pub const RT_THREAD_SUSPEND: u32 = 2;
pub const RT_THREAD_RUNNING: u32 = 3;
pub const RT_THREAD_BLOCK: u32 = 2;
pub const RT_THREAD_CLOSE: u32 = 4;
pub const RT_THREAD_STAT_MASK: u32 = 7;
pub const RT_THREAD_STAT_YIELD: u32 = 8;
pub const RT_THREAD_STAT_YIELD_MASK: u32 = 8;
pub const RT_THREAD_STAT_SIGNAL: u32 = 16;
pub const RT_THREAD_STAT_SIGNAL_READY: u32 = 17;
pub const RT_THREAD_STAT_SIGNAL_WAIT: u32 = 32;
pub const RT_THREAD_STAT_SIGNAL_PENDING: u32 = 64;
pub const RT_THREAD_STAT_SIGNAL_MASK: u32 = 240;
pub const RT_THREAD_CTRL_STARTUP: u32 = 0;
pub const RT_THREAD_CTRL_CLOSE: u32 = 1;
pub const RT_THREAD_CTRL_CHANGE_PRIORITY: u32 = 2;
pub const RT_THREAD_CTRL_INFO: u32 = 3;
pub const RT_THREAD_CTRL_BIND_CPU: u32 = 4;
pub const RT_IPC_FLAG_FIFO: u32 = 0;
pub const RT_IPC_FLAG_PRIO: u32 = 1;
pub const RT_IPC_CMD_UNKNOWN: u32 = 0;
pub const RT_IPC_CMD_RESET: u32 = 1;
pub const RT_WAITING_FOREVER: i32 = -1;
pub const RT_WAITING_NO: u32 = 0;
pub const RT_EVENT_FLAG_AND: u32 = 1;
pub const RT_EVENT_FLAG_OR: u32 = 2;
pub const RT_EVENT_FLAG_CLEAR: u32 = 4;
pub const RT_DEVICE_FLAG_DEACTIVATE: u32 = 0;
pub const RT_DEVICE_FLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_FLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_FLAG_RDWR: u32 = 3;
pub const RT_DEVICE_FLAG_REMOVABLE: u32 = 4;
pub const RT_DEVICE_FLAG_STANDALONE: u32 = 8;
pub const RT_DEVICE_FLAG_ACTIVATED: u32 = 16;
pub const RT_DEVICE_FLAG_SUSPENDED: u32 = 32;
pub const RT_DEVICE_FLAG_STREAM: u32 = 64;
pub const RT_DEVICE_FLAG_INT_RX: u32 = 256;
pub const RT_DEVICE_FLAG_DMA_RX: u32 = 512;
pub const RT_DEVICE_FLAG_INT_TX: u32 = 1024;
pub const RT_DEVICE_FLAG_DMA_TX: u32 = 2048;
pub const RT_DEVICE_OFLAG_CLOSE: u32 = 0;
pub const RT_DEVICE_OFLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_OFLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_OFLAG_RDWR: u32 = 3;
pub const RT_DEVICE_OFLAG_OPEN: u32 = 8;
pub const RT_DEVICE_OFLAG_MASK: u32 = 3855;
pub const RT_DEVICE_CTRL_RESUME: u32 = 1;
pub const RT_DEVICE_CTRL_SUSPEND: u32 = 2;
pub const RT_DEVICE_CTRL_CONFIG: u32 = 3;
pub const RT_DEVICE_CTRL_CLOSE: u32 = 4;
pub const RT_DEVICE_CTRL_SET_INT: u32 = 16;
pub const RT_DEVICE_CTRL_CLR_INT: u32 = 17;
pub const RT_DEVICE_CTRL_GET_INT: u32 = 18;
pub const RT_DEVICE_CTRL_CHAR_STREAM: u32 = 16;
pub const RT_DEVICE_CTRL_BLK_GETGEOME: u32 = 16;
pub const RT_DEVICE_CTRL_BLK_SYNC: u32 = 17;
pub const RT_DEVICE_CTRL_BLK_ERASE: u32 = 18;
pub const RT_DEVICE_CTRL_BLK_AUTOREFRESH: u32 = 19;
pub const RT_DEVICE_CTRL_NETIF_GETMAC: u32 = 16;
pub const RT_DEVICE_CTRL_MTD_FORMAT: u32 = 16;
pub const RT_DEVICE_CTRL_RTC_GET_TIME: u32 = 16;
pub const RT_DEVICE_CTRL_RTC_SET_TIME: u32 = 17;
pub const RT_DEVICE_CTRL_RTC_GET_ALARM: u32 = 18;
pub const RT_DEVICE_CTRL_RTC_SET_ALARM: u32 = 19;
pub const RT_DEVICE_CTRL_CURSOR_SET_POSITION: u32 = 16;
pub const RT_DEVICE_CTRL_CURSOR_SET_TYPE: u32 = 17;
pub const RTGRAPHIC_CTRL_RECT_UPDATE: u32 = 0;
pub const RTGRAPHIC_CTRL_POWERON: u32 = 1;
pub const RTGRAPHIC_CTRL_POWEROFF: u32 = 2;
pub const RTGRAPHIC_CTRL_GET_INFO: u32 = 3;
pub const RTGRAPHIC_CTRL_SET_MODE: u32 = 4;
pub const RTGRAPHIC_CTRL_GET_EXT: u32 = 5;
pub const S_IFMT: u32 = 61440;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFLNK: u32 = 40960;
pub const S_IFREG: u32 = 32768;
pub const S_IFBLK: u32 = 24576;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFIFO: u32 = 4096;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const ULONG_MAX: i32 = -1;
pub const NULL: u32 = 0;
pub const ERROR_BASE_NO: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const ENOTSUP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const O_SYNC: u32 = 1052672;
pub const O_RSYNC: u32 = 1052672;
pub const O_BINARY: u32 = 32768;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_ASYNC: u32 = 8192;
pub const O_DIRECT: u32 = 16384;
pub const O_LARGEFILE: u32 = 32768;
pub const O_NOATIME: u32 = 262144;
pub const O_PATH: u32 = 2097152;
pub const O_TMPFILE: u32 = 4259840;
pub const O_NDELAY: u32 = 2048;
pub const O_SEARCH: u32 = 2097152;
pub const O_EXEC: u32 = 2097152;
pub const O_ACCMODE: u32 = 2097155;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_GETLK: u32 = 12;
pub const F_SETLK: u32 = 13;
pub const F_SETLKW: u32 = 14;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const TCGETS: u32 = 21505;
pub const TCSETS: u32 = 21506;
pub const TCSETSW: u32 = 21507;
pub const TCSETSF: u32 = 21508;
pub const TCGETA: u32 = 21509;
pub const TCSETA: u32 = 21510;
pub const TCSETAW: u32 = 21511;
pub const TCSETAF: u32 = 21512;
pub const TCSBRK: u32 = 21513;
pub const TCXONC: u32 = 21514;
pub const TCFLSH: u32 = 21515;
pub const TIOCEXCL: u32 = 21516;
pub const TIOCNXCL: u32 = 21517;
pub const TIOCSCTTY: u32 = 21518;
pub const TIOCGPGRP: u32 = 21519;
pub const TIOCSPGRP: u32 = 21520;
pub const TIOCOUTQ: u32 = 21521;
pub const TIOCSTI: u32 = 21522;
pub const TIOCGWINSZ: u32 = 21523;
pub const TIOCSWINSZ: u32 = 21524;
pub const TIOCMGET: u32 = 21525;
pub const TIOCMBIS: u32 = 21526;
pub const TIOCMBIC: u32 = 21527;
pub const TIOCMSET: u32 = 21528;
pub const TIOCGSOFTCAR: u32 = 21529;
pub const TIOCSSOFTCAR: u32 = 21530;
pub const TIOCLINUX: u32 = 21532;
pub const TIOCCONS: u32 = 21533;
pub const TIOCGSERIAL: u32 = 21534;
pub const TIOCSSERIAL: u32 = 21535;
pub const TIOCPKT: u32 = 21536;
pub const TIOCNOTTY: u32 = 21538;
pub const TIOCSETD: u32 = 21539;
pub const TIOCGETD: u32 = 21540;
pub const TCSBRKP: u32 = 21541;
pub const TIOCSBRK: u32 = 21543;
pub const TIOCCBRK: u32 = 21544;
pub const TIOCGSID: u32 = 21545;
pub const TIOCGRS485: u32 = 21550;
pub const TIOCSRS485: u32 = 21551;
pub const TIOCGPTN: u32 = 2147767344;
pub const TIOCSPTLCK: u32 = 1074025521;
pub const TIOCGDEV: u32 = 2147767346;
pub const TCGETX: u32 = 21554;
pub const TCSETX: u32 = 21555;
pub const TCSETXF: u32 = 21556;
pub const TCSETXW: u32 = 21557;
pub const TIOCSIG: u32 = 1074025526;
pub const TIOCVHANGUP: u32 = 21559;
pub const TIOCGPKT: u32 = 2147767352;
pub const TIOCGPTLCK: u32 = 2147767353;
pub const TIOCGEXCL: u32 = 2147767360;
pub const FIONCLEX: u32 = 21584;
pub const FIOCLEX: u32 = 21585;
pub const FIOASYNC: u32 = 21586;
pub const TIOCSERCONFIG: u32 = 21587;
pub const TIOCSERGWILD: u32 = 21588;
pub const TIOCSERSWILD: u32 = 21589;
pub const TIOCGLCKTRMIOS: u32 = 21590;
pub const TIOCSLCKTRMIOS: u32 = 21591;
pub const TIOCSERGSTRUCT: u32 = 21592;
pub const TIOCSERGETLSR: u32 = 21593;
pub const TIOCSERGETMULTI: u32 = 21594;
pub const TIOCSERSETMULTI: u32 = 21595;
pub const TIOCMIWAIT: u32 = 21596;
pub const TIOCGICOUNT: u32 = 21597;
pub const FIOQSIZE: u32 = 21600;
pub const TIOCPKT_DATA: u32 = 0;
pub const TIOCPKT_FLUSHREAD: u32 = 1;
pub const TIOCPKT_FLUSHWRITE: u32 = 2;
pub const TIOCPKT_STOP: u32 = 4;
pub const TIOCPKT_START: u32 = 8;
pub const TIOCPKT_NOSTOP: u32 = 16;
pub const TIOCPKT_DOSTOP: u32 = 32;
pub const TIOCPKT_IOCTL: u32 = 64;
pub const TIOCSER_TEMT: u32 = 1;
pub const TIOCM_LE: u32 = 1;
pub const TIOCM_DTR: u32 = 2;
pub const TIOCM_RTS: u32 = 4;
pub const TIOCM_ST: u32 = 8;
pub const TIOCM_SR: u32 = 16;
pub const TIOCM_CTS: u32 = 32;
pub const TIOCM_CAR: u32 = 64;
pub const TIOCM_RNG: u32 = 128;
pub const TIOCM_DSR: u32 = 256;
pub const TIOCM_CD: u32 = 64;
pub const TIOCM_RI: u32 = 128;
pub const TIOCM_OUT1: u32 = 8192;
pub const TIOCM_OUT2: u32 = 16384;
pub const TIOCM_LOOP: u32 = 32768;
pub const N_TTY: u32 = 0;
pub const N_SLIP: u32 = 1;
pub const N_MOUSE: u32 = 2;
pub const N_PPP: u32 = 3;
pub const N_STRIP: u32 = 4;
pub const N_AX25: u32 = 5;
pub const N_X25: u32 = 6;
pub const N_6PACK: u32 = 7;
pub const N_MASC: u32 = 8;
pub const N_R3964: u32 = 9;
pub const N_PROFIBUS_FDL: u32 = 10;
pub const N_IRDA: u32 = 11;
pub const N_SMSBLOCK: u32 = 12;
pub const N_HDLC: u32 = 13;
pub const N_SYNC_PPP: u32 = 14;
pub const N_HCI: u32 = 15;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SIOCADDRT: u32 = 35083;
pub const SIOCDELRT: u32 = 35084;
pub const SIOCRTMSG: u32 = 35085;
pub const SIOCGIFNAME: u32 = 35088;
pub const SIOCSIFLINK: u32 = 35089;
pub const SIOCGIFCONF: u32 = 35090;
pub const SIOCGIFFLAGS: u32 = 35091;
pub const SIOCSIFFLAGS: u32 = 35092;
pub const SIOCGIFADDR: u32 = 35093;
pub const SIOCSIFADDR: u32 = 35094;
pub const SIOCGIFDSTADDR: u32 = 35095;
pub const SIOCSIFDSTADDR: u32 = 35096;
pub const SIOCGIFBRDADDR: u32 = 35097;
pub const SIOCSIFBRDADDR: u32 = 35098;
pub const SIOCGIFNETMASK: u32 = 35099;
pub const SIOCSIFNETMASK: u32 = 35100;
pub const SIOCGIFMETRIC: u32 = 35101;
pub const SIOCSIFMETRIC: u32 = 35102;
pub const SIOCGIFMEM: u32 = 35103;
pub const SIOCSIFMEM: u32 = 35104;
pub const SIOCGIFMTU: u32 = 35105;
pub const SIOCSIFMTU: u32 = 35106;
pub const SIOCSIFNAME: u32 = 35107;
pub const SIOCSIFHWADDR: u32 = 35108;
pub const SIOCGIFENCAP: u32 = 35109;
pub const SIOCSIFENCAP: u32 = 35110;
pub const SIOCGIFHWADDR: u32 = 35111;
pub const SIOCGIFSLAVE: u32 = 35113;
pub const SIOCSIFSLAVE: u32 = 35120;
pub const SIOCADDMULTI: u32 = 35121;
pub const SIOCDELMULTI: u32 = 35122;
pub const SIOCGIFINDEX: u32 = 35123;
pub const SIOGIFINDEX: u32 = 35123;
pub const SIOCSIFPFLAGS: u32 = 35124;
pub const SIOCGIFPFLAGS: u32 = 35125;
pub const SIOCDIFADDR: u32 = 35126;
pub const SIOCSIFHWBROADCAST: u32 = 35127;
pub const SIOCGIFCOUNT: u32 = 35128;
pub const SIOCGIFBR: u32 = 35136;
pub const SIOCSIFBR: u32 = 35137;
pub const SIOCGIFTXQLEN: u32 = 35138;
pub const SIOCSIFTXQLEN: u32 = 35139;
pub const SIOCDARP: u32 = 35155;
pub const SIOCGARP: u32 = 35156;
pub const SIOCSARP: u32 = 35157;
pub const SIOCDRARP: u32 = 35168;
pub const SIOCGRARP: u32 = 35169;
pub const SIOCSRARP: u32 = 35170;
pub const SIOCGIFMAP: u32 = 35184;
pub const SIOCSIFMAP: u32 = 35185;
pub const SIOCADDDLCI: u32 = 35200;
pub const SIOCDELDLCI: u32 = 35201;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_REG: u32 = 1;
pub const DT_DIR: u32 = 2;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const FD_SETSIZE: u32 = 32;
pub const NBBY: u32 = 8;
pub type rt_int8_t = cty::c_schar;
pub type rt_int16_t = cty::c_short;
pub type rt_int32_t = cty::c_int;
pub type rt_uint8_t = cty::c_uchar;
pub type rt_uint16_t = cty::c_ushort;
pub type rt_uint32_t = cty::c_uint;
pub type rt_int64_t = cty::c_longlong;
pub type rt_uint64_t = cty::c_ulonglong;
pub type rt_bool_t = cty::c_int;
pub type rt_base_t = cty::c_long;
pub type rt_ubase_t = cty::c_ulong;
pub type rt_err_t = rt_base_t;
pub type rt_time_t = rt_uint32_t;
pub type rt_tick_t = rt_uint32_t;
pub type rt_flag_t = rt_base_t;
pub type rt_size_t = rt_ubase_t;
pub type rt_dev_t = rt_ubase_t;
pub type rt_off_t = rt_base_t;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type init_fn_t = ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>;
#[doc = " Double List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_list_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_list_node,
    #[doc = "< point to prev node."]
    pub prev: *mut rt_list_node,
}
#[test]
fn bindgen_test_layout_rt_list_node() {
    assert_eq!(
        ::core::mem::size_of::<rt_list_node>(),
        8usize,
        concat!("Size of: ", stringify!(rt_list_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_list_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_list_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_list_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_list_node>())).prev as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(prev)
        )
    );
}
pub type rt_list_t = rt_list_node;
#[doc = " Single List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_slist_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_slist_node,
}
#[test]
fn bindgen_test_layout_rt_slist_node() {
    assert_eq!(
        ::core::mem::size_of::<rt_slist_node>(),
        4usize,
        concat!("Size of: ", stringify!(rt_slist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_slist_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_slist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_slist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_slist_node),
            "::",
            stringify!(next)
        )
    );
}
pub type rt_slist_t = rt_slist_node;
#[doc = " Base structure of Kernel object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object {
    #[doc = "< name of kernel object"]
    pub name: [cty::c_char; 8usize],
    #[doc = "< type of kernel object"]
    pub type_: rt_uint8_t,
    #[doc = "< flag of kernel object"]
    pub flag: rt_uint8_t,
    #[doc = "< list node of kernel object"]
    pub list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_object() {
    assert_eq!(
        ::core::mem::size_of::<rt_object>(),
        20usize,
        concat!("Size of: ", stringify!(rt_object))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_object>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_object))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_object>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_object>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_object>())).flag as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_object>())).list as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(list)
        )
    );
}
pub type rt_object_t = *mut rt_object;
impl rt_object_class_type {
    #[doc = "< The object is not used."]
    pub const RT_Object_Class_Null: rt_object_class_type = rt_object_class_type(0);
}
impl rt_object_class_type {
    #[doc = "< The object is a thread."]
    pub const RT_Object_Class_Thread: rt_object_class_type = rt_object_class_type(1);
}
impl rt_object_class_type {
    #[doc = "< The object is a semaphore."]
    pub const RT_Object_Class_Semaphore: rt_object_class_type = rt_object_class_type(2);
}
impl rt_object_class_type {
    #[doc = "< The object is a mutex."]
    pub const RT_Object_Class_Mutex: rt_object_class_type = rt_object_class_type(3);
}
impl rt_object_class_type {
    #[doc = "< The object is a event."]
    pub const RT_Object_Class_Event: rt_object_class_type = rt_object_class_type(4);
}
impl rt_object_class_type {
    #[doc = "< The object is a mail box."]
    pub const RT_Object_Class_MailBox: rt_object_class_type = rt_object_class_type(5);
}
impl rt_object_class_type {
    #[doc = "< The object is a message queue."]
    pub const RT_Object_Class_MessageQueue: rt_object_class_type = rt_object_class_type(6);
}
impl rt_object_class_type {
    #[doc = "< The object is a memory heap"]
    pub const RT_Object_Class_MemHeap: rt_object_class_type = rt_object_class_type(7);
}
impl rt_object_class_type {
    #[doc = "< The object is a memory pool."]
    pub const RT_Object_Class_MemPool: rt_object_class_type = rt_object_class_type(8);
}
impl rt_object_class_type {
    #[doc = "< The object is a device"]
    pub const RT_Object_Class_Device: rt_object_class_type = rt_object_class_type(9);
}
impl rt_object_class_type {
    #[doc = "< The object is a timer."]
    pub const RT_Object_Class_Timer: rt_object_class_type = rt_object_class_type(10);
}
impl rt_object_class_type {
    #[doc = "< The object is a module."]
    pub const RT_Object_Class_Module: rt_object_class_type = rt_object_class_type(11);
}
impl rt_object_class_type {
    #[doc = "< The object is unknown."]
    pub const RT_Object_Class_Unknown: rt_object_class_type = rt_object_class_type(12);
}
impl rt_object_class_type {
    #[doc = "< The object is a static object."]
    pub const RT_Object_Class_Static: rt_object_class_type = rt_object_class_type(128);
}
#[repr(transparent)]
#[doc = "  The object type can be one of the follows with specific"]
#[doc = "  macros enabled:"]
#[doc = "  - Thread"]
#[doc = "  - Semaphore"]
#[doc = "  - Mutex"]
#[doc = "  - Event"]
#[doc = "  - MailBox"]
#[doc = "  - MessageQueue"]
#[doc = "  - MemHeap"]
#[doc = "  - MemPool"]
#[doc = "  - Device"]
#[doc = "  - Timer"]
#[doc = "  - Module"]
#[doc = "  - Unknown"]
#[doc = "  - Static"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct rt_object_class_type(pub u32);
#[doc = " The information of the kernel object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object_information {
    #[doc = "< object class type"]
    pub type_: rt_object_class_type,
    #[doc = "< object list"]
    pub object_list: rt_list_t,
    #[doc = "< object size"]
    pub object_size: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_object_information() {
    assert_eq!(
        ::core::mem::size_of::<rt_object_information>(),
        16usize,
        concat!("Size of: ", stringify!(rt_object_information))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_object_information>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_object_information))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_object_information>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object_information),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_object_information>())).object_list as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object_information),
            "::",
            stringify!(object_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_object_information>())).object_size as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object_information),
            "::",
            stringify!(object_size)
        )
    );
}
#[doc = " timer structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_timer {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    pub row: [rt_list_t; 1usize],
    #[doc = "< timeout function"]
    pub timeout_func: ::core::option::Option<unsafe extern "C" fn(parameter: *mut cty::c_void)>,
    #[doc = "< timeout function's parameter"]
    pub parameter: *mut cty::c_void,
    #[doc = "< timer timeout tick"]
    pub init_tick: rt_tick_t,
    #[doc = "< timeout tick"]
    pub timeout_tick: rt_tick_t,
}
#[test]
fn bindgen_test_layout_rt_timer() {
    assert_eq!(
        ::core::mem::size_of::<rt_timer>(),
        44usize,
        concat!("Size of: ", stringify!(rt_timer))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_timer>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_timer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_timer>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_timer>())).row as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_timer>())).timeout_func as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_timer>())).parameter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_timer>())).init_tick as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(init_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_timer>())).timeout_tick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_tick)
        )
    );
}
pub type rt_timer_t = *mut rt_timer;
#[doc = " Thread structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_thread {
    #[doc = "< the name of thread"]
    pub name: [cty::c_char; 8usize],
    #[doc = "< type of object"]
    pub type_: rt_uint8_t,
    #[doc = "< thread's flags"]
    pub flags: rt_uint8_t,
    #[doc = "< the object list"]
    pub list: rt_list_t,
    #[doc = "< the thread list"]
    pub tlist: rt_list_t,
    #[doc = "< stack point"]
    pub sp: *mut cty::c_void,
    #[doc = "< entry"]
    pub entry: *mut cty::c_void,
    #[doc = "< parameter"]
    pub parameter: *mut cty::c_void,
    #[doc = "< stack address"]
    pub stack_addr: *mut cty::c_void,
    #[doc = "< stack size"]
    pub stack_size: rt_uint32_t,
    #[doc = "< error code"]
    pub error: rt_err_t,
    #[doc = "< thread status"]
    pub stat: rt_uint8_t,
    #[doc = "< current priority"]
    pub current_priority: rt_uint8_t,
    #[doc = "< initialized priority"]
    pub init_priority: rt_uint8_t,
    pub number_mask: rt_uint32_t,
    pub event_set: rt_uint32_t,
    pub event_info: rt_uint8_t,
    #[doc = "< thread's initialized tick"]
    pub init_tick: rt_ubase_t,
    #[doc = "< remaining tick"]
    pub remaining_tick: rt_ubase_t,
    #[doc = "< built-in thread timer"]
    pub thread_timer: rt_timer,
    #[doc = "< cleanup function when thread exit"]
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>,
    #[doc = "< private user data beyond this thread"]
    pub user_data: rt_ubase_t,
}
#[test]
fn bindgen_test_layout_rt_thread() {
    assert_eq!(
        ::core::mem::size_of::<rt_thread>(),
        128usize,
        concat!("Size of: ", stringify!(rt_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_thread>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).flags as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).list as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).tlist as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(tlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).sp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).entry as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).parameter as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).stack_addr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stack_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).stack_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).error as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).stat as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).current_priority as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(current_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).init_priority as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(init_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).number_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(number_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).event_set as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(event_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).event_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(event_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).init_tick as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(init_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).remaining_tick as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(remaining_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).thread_timer as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(thread_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).cleanup as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_thread>())).user_data as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(user_data)
        )
    );
}
pub type rt_thread_t = *mut rt_thread;
#[doc = " Base structure of IPC object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_ipc_object {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< threads pended on this resource"]
    pub suspend_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_ipc_object() {
    assert_eq!(
        ::core::mem::size_of::<rt_ipc_object>(),
        28usize,
        concat!("Size of: ", stringify!(rt_ipc_object))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_ipc_object>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_ipc_object))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_ipc_object>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_ipc_object>())).suspend_thread as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(suspend_thread)
        )
    );
}
#[doc = " Semaphore structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_semaphore {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< value of semaphore."]
    pub value: rt_uint16_t,
    #[doc = "< reserved field"]
    pub reserved: rt_uint16_t,
}
#[test]
fn bindgen_test_layout_rt_semaphore() {
    assert_eq!(
        ::core::mem::size_of::<rt_semaphore>(),
        32usize,
        concat!("Size of: ", stringify!(rt_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_semaphore>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_semaphore>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_semaphore>())).value as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_semaphore>())).reserved as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rt_sem_t = *mut rt_semaphore;
#[doc = " Mutual exclusion (mutex) structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< value of mutex"]
    pub value: rt_uint16_t,
    #[doc = "< priority of last thread hold the mutex"]
    pub original_priority: rt_uint8_t,
    #[doc = "< numbers of thread hold the mutex"]
    pub hold: rt_uint8_t,
    #[doc = "< current owner of mutex"]
    pub owner: *mut rt_thread,
}
#[test]
fn bindgen_test_layout_rt_mutex() {
    assert_eq!(
        ::core::mem::size_of::<rt_mutex>(),
        36usize,
        concat!("Size of: ", stringify!(rt_mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mutex>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mutex>())).value as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mutex>())).original_priority as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(original_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mutex>())).hold as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mutex>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(owner)
        )
    );
}
pub type rt_mutex_t = *mut rt_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_event {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< event set"]
    pub set: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_event() {
    assert_eq!(
        ::core::mem::size_of::<rt_event>(),
        32usize,
        concat!("Size of: ", stringify!(rt_event))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_event>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_event>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_event>())).set as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(set)
        )
    );
}
pub type rt_event_t = *mut rt_event;
#[doc = " mailbox structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mailbox {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< start address of message buffer"]
    pub msg_pool: *mut rt_ubase_t,
    #[doc = "< size of message pool"]
    pub size: rt_uint16_t,
    #[doc = "< index of messages in msg_pool"]
    pub entry: rt_uint16_t,
    #[doc = "< input offset of the message buffer"]
    pub in_offset: rt_uint16_t,
    #[doc = "< output offset of the message buffer"]
    pub out_offset: rt_uint16_t,
    #[doc = "< sender thread suspended on this mailbox"]
    pub suspend_sender_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_mailbox() {
    assert_eq!(
        ::core::mem::size_of::<rt_mailbox>(),
        48usize,
        concat!("Size of: ", stringify!(rt_mailbox))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mailbox>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mailbox))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mailbox>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mailbox>())).msg_pool as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(msg_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mailbox>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mailbox>())).entry as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mailbox>())).in_offset as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(in_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mailbox>())).out_offset as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(out_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_mailbox>())).suspend_sender_thread as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(suspend_sender_thread)
        )
    );
}
pub type rt_mailbox_t = *mut rt_mailbox;
#[doc = " message queue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_messagequeue {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< start address of message queue"]
    pub msg_pool: *mut cty::c_void,
    #[doc = "< message size of each message"]
    pub msg_size: rt_uint16_t,
    #[doc = "< max number of messages"]
    pub max_msgs: rt_uint16_t,
    #[doc = "< index of messages in the queue"]
    pub entry: rt_uint16_t,
    #[doc = "< list head"]
    pub msg_queue_head: *mut cty::c_void,
    #[doc = "< list tail"]
    pub msg_queue_tail: *mut cty::c_void,
    #[doc = "< pointer indicated the free node of queue"]
    pub msg_queue_free: *mut cty::c_void,
    #[doc = "< sender thread suspended on this message queue"]
    pub suspend_sender_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_messagequeue() {
    assert_eq!(
        ::core::mem::size_of::<rt_messagequeue>(),
        60usize,
        concat!("Size of: ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_messagequeue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).msg_pool as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).msg_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).max_msgs as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(max_msgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).entry as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).msg_queue_head as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).msg_queue_tail as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_messagequeue>())).msg_queue_free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_messagequeue>())).suspend_sender_thread as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(suspend_sender_thread)
        )
    );
}
pub type rt_mq_t = *mut rt_messagequeue;
#[doc = " Base structure of Memory pool object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mempool {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< memory pool start"]
    pub start_address: *mut cty::c_void,
    #[doc = "< size of memory pool"]
    pub size: rt_size_t,
    #[doc = "< size of memory blocks"]
    pub block_size: rt_size_t,
    #[doc = "< memory blocks list"]
    pub block_list: *mut rt_uint8_t,
    #[doc = "< numbers of memory block"]
    pub block_total_count: rt_size_t,
    #[doc = "< numbers of free memory block"]
    pub block_free_count: rt_size_t,
    #[doc = "< threads pended on this resource"]
    pub suspend_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_mempool() {
    assert_eq!(
        ::core::mem::size_of::<rt_mempool>(),
        52usize,
        concat!("Size of: ", stringify!(rt_mempool))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mempool>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mempool))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).start_address as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(start_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).block_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).block_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).block_total_count as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_total_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).block_free_count as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_free_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_mempool>())).suspend_thread as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(suspend_thread)
        )
    );
}
pub type rt_mp_t = *mut rt_mempool;
impl rt_device_class_type {
    #[doc = "< character device"]
    pub const RT_Device_Class_Char: rt_device_class_type = rt_device_class_type(0);
}
impl rt_device_class_type {
    #[doc = "< block device"]
    pub const RT_Device_Class_Block: rt_device_class_type = rt_device_class_type(1);
}
impl rt_device_class_type {
    #[doc = "< net interface"]
    pub const RT_Device_Class_NetIf: rt_device_class_type = rt_device_class_type(2);
}
impl rt_device_class_type {
    #[doc = "< memory device"]
    pub const RT_Device_Class_MTD: rt_device_class_type = rt_device_class_type(3);
}
impl rt_device_class_type {
    #[doc = "< CAN device"]
    pub const RT_Device_Class_CAN: rt_device_class_type = rt_device_class_type(4);
}
impl rt_device_class_type {
    #[doc = "< RTC device"]
    pub const RT_Device_Class_RTC: rt_device_class_type = rt_device_class_type(5);
}
impl rt_device_class_type {
    #[doc = "< Sound device"]
    pub const RT_Device_Class_Sound: rt_device_class_type = rt_device_class_type(6);
}
impl rt_device_class_type {
    #[doc = "< Graphic device"]
    pub const RT_Device_Class_Graphic: rt_device_class_type = rt_device_class_type(7);
}
impl rt_device_class_type {
    #[doc = "< I2C bus device"]
    pub const RT_Device_Class_I2CBUS: rt_device_class_type = rt_device_class_type(8);
}
impl rt_device_class_type {
    #[doc = "< USB slave device"]
    pub const RT_Device_Class_USBDevice: rt_device_class_type = rt_device_class_type(9);
}
impl rt_device_class_type {
    #[doc = "< USB host bus"]
    pub const RT_Device_Class_USBHost: rt_device_class_type = rt_device_class_type(10);
}
impl rt_device_class_type {
    #[doc = "< SPI bus device"]
    pub const RT_Device_Class_SPIBUS: rt_device_class_type = rt_device_class_type(11);
}
impl rt_device_class_type {
    #[doc = "< SPI device"]
    pub const RT_Device_Class_SPIDevice: rt_device_class_type = rt_device_class_type(12);
}
impl rt_device_class_type {
    #[doc = "< SDIO bus device"]
    pub const RT_Device_Class_SDIO: rt_device_class_type = rt_device_class_type(13);
}
impl rt_device_class_type {
    #[doc = "< PM pseudo device"]
    pub const RT_Device_Class_PM: rt_device_class_type = rt_device_class_type(14);
}
impl rt_device_class_type {
    #[doc = "< Pipe device"]
    pub const RT_Device_Class_Pipe: rt_device_class_type = rt_device_class_type(15);
}
impl rt_device_class_type {
    #[doc = "< Portal device"]
    pub const RT_Device_Class_Portal: rt_device_class_type = rt_device_class_type(16);
}
impl rt_device_class_type {
    #[doc = "< Timer device"]
    pub const RT_Device_Class_Timer: rt_device_class_type = rt_device_class_type(17);
}
impl rt_device_class_type {
    #[doc = "< Miscellaneous device"]
    pub const RT_Device_Class_Miscellaneous: rt_device_class_type = rt_device_class_type(18);
}
impl rt_device_class_type {
    #[doc = "< Sensor device"]
    pub const RT_Device_Class_Sensor: rt_device_class_type = rt_device_class_type(19);
}
impl rt_device_class_type {
    #[doc = "< Touch device"]
    pub const RT_Device_Class_Touch: rt_device_class_type = rt_device_class_type(20);
}
impl rt_device_class_type {
    #[doc = "< unknown device"]
    pub const RT_Device_Class_Unknown: rt_device_class_type = rt_device_class_type(21);
}
#[repr(transparent)]
#[doc = " device (I/O) class type"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct rt_device_class_type(pub u32);
pub type rt_device_t = *mut rt_device;
#[doc = " operations set for device object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_ops {
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut cty::c_void,
            size: rt_size_t,
        ) -> rt_size_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const cty::c_void,
            size: rt_size_t,
        ) -> rt_size_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, cmd: cty::c_int, args: *mut cty::c_void) -> rt_err_t,
    >,
}
#[test]
fn bindgen_test_layout_rt_device_ops() {
    assert_eq!(
        ::core::mem::size_of::<rt_device_ops>(),
        24usize,
        concat!("Size of: ", stringify!(rt_device_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_ops>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_ops>())).open as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_ops>())).close as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_ops>())).read as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_ops>())).write as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_ops>())).control as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(control)
        )
    );
}
#[doc = " WaitQueue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_wqueue {
    pub flag: rt_uint32_t,
    pub waiting_list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_wqueue() {
    assert_eq!(
        ::core::mem::size_of::<rt_wqueue>(),
        12usize,
        concat!("Size of: ", stringify!(rt_wqueue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_wqueue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_wqueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_wqueue>())).flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_wqueue>())).waiting_list as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(waiting_list)
        )
    );
}
pub type rt_wqueue_t = rt_wqueue;
#[doc = " Device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< device type"]
    pub type_: rt_device_class_type,
    #[doc = "< device flag"]
    pub flag: rt_uint16_t,
    #[doc = "< device open flag"]
    pub open_flag: rt_uint16_t,
    #[doc = "< reference count"]
    pub ref_count: rt_uint8_t,
    #[doc = "< 0 - 255"]
    pub device_id: rt_uint8_t,
    pub rx_indicate:
        ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t>,
    pub tx_complete: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, buffer: *mut cty::c_void) -> rt_err_t,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut cty::c_void,
            size: rt_size_t,
        ) -> rt_size_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const cty::c_void,
            size: rt_size_t,
        ) -> rt_size_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, cmd: cty::c_int, args: *mut cty::c_void) -> rt_err_t,
    >,
    #[doc = "< device private data"]
    pub user_data: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_rt_device() {
    assert_eq!(
        ::core::mem::size_of::<rt_device>(),
        68usize,
        concat!("Size of: ", stringify!(rt_device))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).flag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).open_flag as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(open_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).ref_count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).device_id as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).rx_indicate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(rx_indicate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).tx_complete as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(tx_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).init as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).open as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).close as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).read as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).write as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).control as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device>())).user_data as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " block device geometry structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_geometry {
    #[doc = "< count of sectors"]
    pub sector_count: rt_uint32_t,
    #[doc = "< number of bytes per sector"]
    pub bytes_per_sector: rt_uint32_t,
    #[doc = "< number of bytes to erase one block"]
    pub block_size: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_geometry() {
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_geometry>(),
        12usize,
        concat!("Size of: ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_geometry>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_blk_geometry>())).sector_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(sector_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_blk_geometry>())).bytes_per_sector as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(bytes_per_sector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_blk_geometry>())).block_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(block_size)
        )
    );
}
#[doc = " sector arrange struct on block device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_sectors {
    #[doc = "< begin sector"]
    pub sector_begin: rt_uint32_t,
    #[doc = "< end sector"]
    pub sector_end: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_sectors() {
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_sectors>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_sectors>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_blk_sectors>())).sector_begin as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_blk_sectors>())).sector_end as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_end)
        )
    );
}
pub const RTGRAPHIC_PIXEL_FORMAT_MONO: _bindgen_ty_1 = _bindgen_ty_1(0);
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY4: _bindgen_ty_1 = _bindgen_ty_1(1);
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY16: _bindgen_ty_1 = _bindgen_ty_1(2);
pub const RTGRAPHIC_PIXEL_FORMAT_RGB332: _bindgen_ty_1 = _bindgen_ty_1(3);
pub const RTGRAPHIC_PIXEL_FORMAT_RGB444: _bindgen_ty_1 = _bindgen_ty_1(4);
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565: _bindgen_ty_1 = _bindgen_ty_1(5);
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565P: _bindgen_ty_1 = _bindgen_ty_1(6);
pub const RTGRAPHIC_PIXEL_FORMAT_BGR565: _bindgen_ty_1 = _bindgen_ty_1(6);
pub const RTGRAPHIC_PIXEL_FORMAT_RGB666: _bindgen_ty_1 = _bindgen_ty_1(7);
pub const RTGRAPHIC_PIXEL_FORMAT_RGB888: _bindgen_ty_1 = _bindgen_ty_1(8);
pub const RTGRAPHIC_PIXEL_FORMAT_ARGB888: _bindgen_ty_1 = _bindgen_ty_1(9);
pub const RTGRAPHIC_PIXEL_FORMAT_ABGR888: _bindgen_ty_1 = _bindgen_ty_1(10);
pub const RTGRAPHIC_PIXEL_FORMAT_ARGB565: _bindgen_ty_1 = _bindgen_ty_1(11);
pub const RTGRAPHIC_PIXEL_FORMAT_ALPHA: _bindgen_ty_1 = _bindgen_ty_1(12);
pub const RTGRAPHIC_PIXEL_FORMAT_COLOR: _bindgen_ty_1 = _bindgen_ty_1(13);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_1(pub u32);
#[doc = " graphic device information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_info {
    #[doc = "< graphic format"]
    pub pixel_format: rt_uint8_t,
    #[doc = "< bits per pixel"]
    pub bits_per_pixel: rt_uint8_t,
    #[doc = "< reserved field"]
    pub reserved: rt_uint16_t,
    #[doc = "< width of graphic device"]
    pub width: rt_uint16_t,
    #[doc = "< height of graphic device"]
    pub height: rt_uint16_t,
    #[doc = "< frame buffer"]
    pub framebuffer: *mut rt_uint8_t,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_info() {
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_info>(),
        12usize,
        concat!("Size of: ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_info>())).pixel_format as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_info>())).bits_per_pixel as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_info>())).reserved as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_graphic_info>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_graphic_info>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_info>())).framebuffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(framebuffer)
        )
    );
}
#[doc = " rectangle information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_rect_info {
    #[doc = "< x coordinate"]
    pub x: rt_uint16_t,
    #[doc = "< y coordinate"]
    pub y: rt_uint16_t,
    #[doc = "< width"]
    pub width: rt_uint16_t,
    #[doc = "< height"]
    pub height: rt_uint16_t,
}
#[test]
fn bindgen_test_layout_rt_device_rect_info() {
    assert_eq!(
        ::core::mem::size_of::<rt_device_rect_info>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_rect_info>(),
        2usize,
        concat!("Alignment of ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_rect_info>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_rect_info>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_rect_info>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rt_device_rect_info>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " graphic operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_ops {
    pub set_pixel: ::core::option::Option<
        unsafe extern "C" fn(pixel: *const cty::c_char, x: cty::c_int, y: cty::c_int),
    >,
    pub get_pixel: ::core::option::Option<
        unsafe extern "C" fn(pixel: *mut cty::c_char, x: cty::c_int, y: cty::c_int),
    >,
    pub draw_hline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const cty::c_char,
            x1: cty::c_int,
            x2: cty::c_int,
            y: cty::c_int,
        ),
    >,
    pub draw_vline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const cty::c_char,
            x: cty::c_int,
            y1: cty::c_int,
            y2: cty::c_int,
        ),
    >,
    pub blit_line: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const cty::c_char,
            x: cty::c_int,
            y: cty::c_int,
            size: rt_size_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_ops() {
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_ops>(),
        20usize,
        concat!("Size of: ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_ops>())).set_pixel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(set_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_ops>())).get_pixel as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(get_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_ops>())).draw_hline as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_hline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_ops>())).draw_vline as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_vline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rt_device_graphic_ops>())).blit_line as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(blit_line)
        )
    );
}
pub type int_least8_t = cty::c_schar;
pub type int_least16_t = cty::c_short;
pub type int_least32_t = cty::c_int;
pub type int_least64_t = cty::c_longlong;
pub type uint_least8_t = cty::c_uchar;
pub type uint_least16_t = cty::c_ushort;
pub type uint_least32_t = cty::c_uint;
pub type uint_least64_t = cty::c_ulonglong;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_short;
pub type int_fast32_t = cty::c_int;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ushort;
pub type uint_fast32_t = cty::c_uint;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = cty::c_longlong;
pub type uintmax_t = cty::c_ulonglong;
pub type off_t = cty::c_long;
pub type size_t = cty::c_uint;
pub type ssize_t = cty::c_int;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type clockid_t = cty::c_ulong;
pub type pid_t = cty::c_int;
pub type gid_t = cty::c_int;
pub type uid_t = cty::c_int;
pub type dev_t = cty::c_int;
pub type ino_t = cty::c_int;
pub type mode_t = cty::c_int;
pub type caddr_t = cty::c_int;
pub type wint_t = cty::c_uint;
pub type useconds_t = cty::c_ulong;
pub type clock_t = cty::c_ulong;
pub type time_t = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: cty::c_long,
    pub tv_usec: cty::c_long,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: cty::c_int,
    pub tz_dsttime: cty::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::core::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::core::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: cty::c_int,
    pub tm_min: cty::c_int,
    pub tm_hour: cty::c_int,
    pub tm_mday: cty::c_int,
    pub tm_mon: cty::c_int,
    pub tm_year: cty::c_int,
    pub tm_wday: cty::c_int,
    pub tm_yday: cty::c_int,
    pub tm_isdst: cty::c_int,
    pub tm_gmtoff: cty::c_long,
    pub tm_zone: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        44usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_zone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub fn gettimeofday(tp: *mut timeval, ignore: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn mktime(t: *mut tm) -> time_t;
}
extern "C" {
    pub fn asctime(timeptr: *const tm) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime(timep: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn localtime(t: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn asctime_r(t: *const tm, buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn gmtime_r(timep: *const time_t, r: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(t: *const time_t, r: *mut tm) -> *mut tm;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: *mut rt_device,
    pub st_ino: u16,
    pub st_mode: u16,
    pub st_nlink: u16,
    pub st_uid: u16,
    pub st_gid: u16,
    pub st_rdev: *mut rt_device,
    pub st_size: u32,
    pub st_atime: time_t,
    pub st_spare1: cty::c_long,
    pub st_mtime: time_t,
    pub st_spare2: cty::c_long,
    pub st_ctime: time_t,
    pub st_spare3: cty::c_long,
    pub st_blksize: u32,
    pub st_blocks: u32,
    pub st_spare4: [cty::c_long; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::core::mem::size_of::<stat>(),
        64usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::core::mem::align_of::<stat>(),
        4usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_ino as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_mode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_nlink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_uid as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_gid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_rdev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_atime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_spare1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_mtime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_spare2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_ctime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_spare3 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_spare3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_blksize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_blocks as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stat>())).st_spare4 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_spare4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: cty::c_ushort,
    pub ws_col: cty::c_ushort,
    pub ws_xpixel: cty::c_ushort,
    pub ws_ypixel: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_winsize() {
    assert_eq!(
        ::core::mem::size_of::<winsize>(),
        8usize,
        concat!("Size of: ", stringify!(winsize))
    );
    assert_eq!(
        ::core::mem::align_of::<winsize>(),
        2usize,
        concat!("Alignment of ", stringify!(winsize))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<winsize>())).ws_row as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_row)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<winsize>())).ws_col as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_col)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<winsize>())).ws_xpixel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_xpixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<winsize>())).ws_ypixel as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_ypixel)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: cty::c_int,
    pub sival_ptr: *mut cty::c_void,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::core::mem::size_of::<sigval>(),
        4usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::core::mem::align_of::<sigval>(),
        4usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: cty::c_int,
    pub sigev_signo: cty::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::core::mem::size_of::<sigevent>(),
        20usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent>(),
        4usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub si_signo: rt_uint16_t,
    pub si_code: rt_uint16_t,
    pub si_value: sigval,
}
#[test]
fn bindgen_test_layout_siginfo() {
    assert_eq!(
        ::core::mem::size_of::<siginfo>(),
        8usize,
        concat!("Size of: ", stringify!(siginfo))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo>(),
        4usize,
        concat!("Alignment of ", stringify!(siginfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_code as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_value)
        )
    );
}
pub type siginfo_t = siginfo;
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>;
pub type sigset_t = cty::c_ulong;
pub type fd_mask = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        4usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    #[doc = "@{"]
    pub fn rt_system_object_init();
}
extern "C" {
    pub fn rt_object_get_information(type_: rt_object_class_type) -> *mut rt_object_information;
}
extern "C" {
    pub fn rt_object_get_length(type_: rt_object_class_type) -> cty::c_int;
}
extern "C" {
    pub fn rt_object_get_pointers(
        type_: rt_object_class_type,
        pointers: *mut rt_object_t,
        maxlen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn rt_object_init(
        object: *mut rt_object,
        type_: rt_object_class_type,
        name: *const cty::c_char,
    );
}
extern "C" {
    pub fn rt_object_detach(object: rt_object_t);
}
extern "C" {
    pub fn rt_object_allocate(type_: rt_object_class_type, name: *const cty::c_char)
        -> rt_object_t;
}
extern "C" {
    pub fn rt_object_delete(object: rt_object_t);
}
extern "C" {
    pub fn rt_object_is_systemobject(object: rt_object_t) -> rt_bool_t;
}
extern "C" {
    pub fn rt_object_get_type(object: rt_object_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_object_find(name: *const cty::c_char, type_: rt_uint8_t) -> rt_object_t;
}
extern "C" {
    pub fn rt_object_attach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_detach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_trytake_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_take_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_put_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    #[doc = "@{"]
    pub fn rt_system_tick_init();
}
extern "C" {
    pub fn rt_tick_get() -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_set(tick: rt_tick_t);
}
extern "C" {
    pub fn rt_tick_increase();
}
extern "C" {
    pub fn rt_tick_from_millisecond(ms: rt_int32_t) -> rt_tick_t;
}
extern "C" {
    pub fn rt_system_timer_init();
}
extern "C" {
    pub fn rt_system_timer_thread_init();
}
extern "C" {
    pub fn rt_timer_init(
        timer: rt_timer_t,
        name: *const cty::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut cty::c_void)>,
        parameter: *mut cty::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    );
}
extern "C" {
    pub fn rt_timer_detach(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_create(
        name: *const cty::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut cty::c_void)>,
        parameter: *mut cty::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    ) -> rt_timer_t;
}
extern "C" {
    pub fn rt_timer_delete(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_start(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_stop(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_control(timer: rt_timer_t, cmd: cty::c_int, arg: *mut cty::c_void) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_next_timeout_tick() -> rt_tick_t;
}
extern "C" {
    pub fn rt_timer_check();
}
extern "C" {
    pub fn rt_timer_enter_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
}
extern "C" {
    pub fn rt_timer_exit_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
}
extern "C" {
    #[doc = "@{"]
    pub fn rt_thread_init(
        thread: *mut rt_thread,
        name: *const cty::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut cty::c_void)>,
        parameter: *mut cty::c_void,
        stack_start: *mut cty::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_detach(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_create(
        name: *const cty::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut cty::c_void)>,
        parameter: *mut cty::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_self() -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_find(name: *mut cty::c_char) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_startup(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_delete(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_yield() -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_delay(tick: rt_tick_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_delay_until(tick: *mut rt_tick_t, inc_tick: rt_tick_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_mdelay(ms: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_control(
        thread: rt_thread_t,
        cmd: cty::c_int,
        arg: *mut cty::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_resume(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_timeout(parameter: *mut cty::c_void);
}
extern "C" {
    pub fn rt_thread_suspend_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_resume_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_inited_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_idle_init();
}
extern "C" {
    pub fn rt_thread_idle_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_delhook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_excute();
}
extern "C" {
    pub fn rt_thread_idle_gethandler() -> rt_thread_t;
}
extern "C" {
    pub fn rt_system_scheduler_init();
}
extern "C" {
    pub fn rt_system_scheduler_start();
}
extern "C" {
    pub fn rt_schedule();
}
extern "C" {
    pub fn rt_schedule_insert_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_schedule_remove_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_enter_critical();
}
extern "C" {
    pub fn rt_exit_critical();
}
extern "C" {
    pub fn rt_critical_level() -> rt_uint16_t;
}
extern "C" {
    pub fn rt_scheduler_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(from: rt_thread_t, to: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_mp_init(
        mp: *mut rt_mempool,
        name: *const cty::c_char,
        start: *mut cty::c_void,
        size: rt_size_t,
        block_size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mp_detach(mp: *mut rt_mempool) -> rt_err_t;
}
extern "C" {
    pub fn rt_mp_create(
        name: *const cty::c_char,
        block_count: rt_size_t,
        block_size: rt_size_t,
    ) -> rt_mp_t;
}
extern "C" {
    pub fn rt_mp_delete(mp: rt_mp_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mp_alloc(mp: rt_mp_t, time: rt_int32_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_mp_free(block: *mut cty::c_void);
}
extern "C" {
    pub fn rt_mp_alloc_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(mp: *mut rt_mempool, block: *mut cty::c_void),
        >,
    );
}
extern "C" {
    pub fn rt_mp_free_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(mp: *mut rt_mempool, block: *mut cty::c_void),
        >,
    );
}
extern "C" {
    pub fn rt_system_heap_init(begin_addr: *mut cty::c_void, end_addr: *mut cty::c_void);
}
extern "C" {
    pub fn rt_malloc(nbytes: rt_size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_free(ptr: *mut cty::c_void);
}
extern "C" {
    pub fn rt_realloc(ptr: *mut cty::c_void, nbytes: rt_size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_calloc(count: rt_size_t, size: rt_size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_malloc_align(size: rt_size_t, align: rt_size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_free_align(ptr: *mut cty::c_void);
}
extern "C" {
    pub fn rt_memory_info(
        total: *mut rt_uint32_t,
        used: *mut rt_uint32_t,
        max_used: *mut rt_uint32_t,
    );
}
extern "C" {
    pub fn rt_malloc_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(ptr: *mut cty::c_void, size: rt_size_t)>,
    );
}
extern "C" {
    pub fn rt_free_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(ptr: *mut cty::c_void)>,
    );
}
extern "C" {
    pub fn rt_sem_init(
        sem: rt_sem_t,
        name: *const cty::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_detach(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_create(
        name: *const cty::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_sem_t;
}
extern "C" {
    pub fn rt_sem_delete(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take(sem: rt_sem_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_trytake(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_release(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_control(sem: rt_sem_t, cmd: cty::c_int, arg: *mut cty::c_void) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_init(mutex: rt_mutex_t, name: *const cty::c_char, flag: rt_uint8_t)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_detach(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_create(name: *const cty::c_char, flag: rt_uint8_t) -> rt_mutex_t;
}
extern "C" {
    pub fn rt_mutex_delete(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_take(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_release(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_control(mutex: rt_mutex_t, cmd: cty::c_int, arg: *mut cty::c_void) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_init(event: rt_event_t, name: *const cty::c_char, flag: rt_uint8_t)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_event_detach(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_create(name: *const cty::c_char, flag: rt_uint8_t) -> rt_event_t;
}
extern "C" {
    pub fn rt_event_delete(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_send(event: rt_event_t, set: rt_uint32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_control(event: rt_event_t, cmd: cty::c_int, arg: *mut cty::c_void) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_init(
        mb: rt_mailbox_t,
        name: *const cty::c_char,
        msgpool: *mut cty::c_void,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_detach(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_create(
        name: *const cty::c_char,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mailbox_t;
}
extern "C" {
    pub fn rt_mb_delete(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait(mb: rt_mailbox_t, value: rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv(mb: rt_mailbox_t, value: *mut rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_control(mb: rt_mailbox_t, cmd: cty::c_int, arg: *mut cty::c_void) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_init(
        mq: rt_mq_t,
        name: *const cty::c_char,
        msgpool: *mut cty::c_void,
        msg_size: rt_size_t,
        pool_size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_detach(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_create(
        name: *const cty::c_char,
        msg_size: rt_size_t,
        max_msgs: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mq_t;
}
extern "C" {
    pub fn rt_mq_delete(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send(mq: rt_mq_t, buffer: *const cty::c_void, size: rt_size_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait(
        mq: rt_mq_t,
        buffer: *const cty::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_urgent(mq: rt_mq_t, buffer: *const cty::c_void, size: rt_size_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_recv(
        mq: rt_mq_t,
        buffer: *mut cty::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_control(mq: rt_mq_t, cmd: cty::c_int, arg: *mut cty::c_void) -> rt_err_t;
}
extern "C" {
    #[doc = "@{"]
    pub fn rt_device_find(name: *const cty::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_register(
        dev: rt_device_t,
        name: *const cty::c_char,
        flags: rt_uint16_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_unregister(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_create(type_: cty::c_int, attach_size: cty::c_int) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_destroy(device: rt_device_t);
}
extern "C" {
    pub fn rt_device_init_all() -> rt_err_t;
}
extern "C" {
    pub fn rt_device_set_rx_indicate(
        dev: rt_device_t,
        rx_ind: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_set_tx_complete(
        dev: rt_device_t,
        tx_done: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, buffer: *mut cty::c_void) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_init(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_open(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_close(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_read(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *mut cty::c_void,
        size: rt_size_t,
    ) -> rt_size_t;
}
extern "C" {
    pub fn rt_device_write(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *const cty::c_void,
        size: rt_size_t,
    ) -> rt_size_t;
}
extern "C" {
    pub fn rt_device_control(dev: rt_device_t, cmd: cty::c_int, arg: *mut cty::c_void) -> rt_err_t;
}
extern "C" {
    pub fn rt_interrupt_enter();
}
extern "C" {
    pub fn rt_interrupt_leave();
}
extern "C" {
    pub fn rt_interrupt_get_nest() -> rt_uint8_t;
}
extern "C" {
    pub fn rt_interrupt_enter_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_interrupt_leave_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_components_init();
}
extern "C" {
    pub fn rt_components_board_init();
}
extern "C" {
    pub fn rt_kprintf(fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn rt_kputs(str_: *const cty::c_char);
}
extern "C" {
    pub fn rt_vsprintf(
        dest: *mut cty::c_char,
        format: *const cty::c_char,
        arg_ptr: va_list,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_vsnprintf(
        buf: *mut cty::c_char,
        size: rt_size_t,
        fmt: *const cty::c_char,
        args: va_list,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_sprintf(buf: *mut cty::c_char, format: *const cty::c_char, ...) -> rt_int32_t;
}
extern "C" {
    pub fn rt_snprintf(
        buf: *mut cty::c_char,
        size: rt_size_t,
        format: *const cty::c_char,
        ...
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_console_set_device(name: *const cty::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_console_get_device() -> rt_device_t;
}
extern "C" {
    pub fn rt_get_errno() -> rt_err_t;
}
extern "C" {
    pub fn rt_set_errno(no: rt_err_t);
}
extern "C" {
    pub fn _rt_errno() -> *mut cty::c_int;
}
extern "C" {
    pub fn __rt_ffs(value: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn rt_memset(src: *mut cty::c_void, c: cty::c_int, n: rt_ubase_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_memcpy(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: rt_ubase_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_strncmp(
        cs: *const cty::c_char,
        ct: *const cty::c_char,
        count: rt_ubase_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcmp(cs: *const cty::c_char, ct: *const cty::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strlen(src: *const cty::c_char) -> rt_size_t;
}
extern "C" {
    pub fn rt_strnlen(s: *const cty::c_char, maxlen: rt_ubase_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_strdup(s: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn rt_strstr(str1: *const cty::c_char, str2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn rt_sscanf(buf: *const cty::c_char, fmt: *const cty::c_char, ...) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strncpy(
        dest: *mut cty::c_char,
        src: *const cty::c_char,
        n: rt_ubase_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn rt_memmove(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: rt_ubase_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn rt_memcmp(
        cs: *const cty::c_void,
        ct: *const cty::c_void,
        count: rt_ubase_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcasecmp(a: *const cty::c_char, b: *const cty::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_show_version();
}
extern "C" {
    pub static mut rt_assert_hook: ::core::option::Option<
        unsafe extern "C" fn(ex: *const cty::c_char, func: *const cty::c_char, line: rt_size_t),
    >;
}
extern "C" {
    pub fn rt_assert_set_hook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(ex: *const cty::c_char, func: *const cty::c_char, line: rt_size_t),
        >,
    );
}
extern "C" {
    pub fn rt_assert_handler(ex: *const cty::c_char, func: *const cty::c_char, line: rt_size_t);
}
pub type syscall_func = ::core::option::Option<unsafe extern "C" fn() -> cty::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall {
    pub name: *const cty::c_char,
    pub desc: *const cty::c_char,
    pub func: syscall_func,
}
#[test]
fn bindgen_test_layout_finsh_syscall() {
    assert_eq!(
        ::core::mem::size_of::<finsh_syscall>(),
        12usize,
        concat!("Size of: ", stringify!(finsh_syscall))
    );
    assert_eq!(
        ::core::mem::align_of::<finsh_syscall>(),
        4usize,
        concat!("Alignment of ", stringify!(finsh_syscall))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<finsh_syscall>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<finsh_syscall>())).desc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<finsh_syscall>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(func)
        )
    );
}
extern "C" {
    pub static mut _syscall_table_begin: *mut finsh_syscall;
}
extern "C" {
    pub static mut _syscall_table_end: *mut finsh_syscall;
}
extern "C" {
    pub fn finsh_syscall_lookup(name: *const cty::c_char) -> *mut finsh_syscall;
}
pub type __builtin_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list {
    pub __ap: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list() {
    assert_eq!(
        ::core::mem::size_of::<__va_list>(),
        4usize,
        concat!("Size of: ", stringify!(__va_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list>(),
        4usize,
        concat!("Alignment of ", stringify!(__va_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list>())).__ap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list),
            "::",
            stringify!(__ap)
        )
    );
}
